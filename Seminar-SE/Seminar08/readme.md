
## Ключовата дума static
Можем да използваме `static` в три различни контекста.

### static променливи във функции
```cpp
#include<iostream>

void f() {
    static int i = 0;   // Инициализира се веднъж
    i++;
    std::cout << i << std::endl;
}

int main() {
    f();
    f();
    f();
}
```
`Изход: 1, 2, 3`

Променливите декларирани във функция като статик се инициализират точно веднъж.

### static функции
```cpp
static void f() {
    // some work...
}
```
Статичните функции в някакъв смисъл са единствено предназначени само за .cpp файла в който са дефинирани. По подразбиране функциите са глобални, т.е. други .cpp файлове могат да ги виждат и да ги използват. Това може да доведе и до проблеми със свързването (linking), примерно когато се дублират имена. 

Този тип функции също се използва като оптимизация за linker-ът. Еквивалентно е на анонимния namespace изучаван на лекции.
### static в класове
```cpp
class Entity {
private:
    static int x; // Не принадлежи на никой обект. Споделя се между обекти. Единствена.
public:
    static void f() {
        // do work
    }
};

int Entity::x = 0;

int main() {
    Entity::f();
}
```
Статичните член-данни в класа са в някакъв смисъл единствени. Те не принадлежат на никой обект и отново се инициализират точно веднъж.
Статичните член-данни в класовете имат множество приложения като:
* Броене на инстанциите (създадени инстанции или живи инстанции)
* Реализация на Singleton design pattern в C++.
* Събиране на данни от всички обекти.

Можем и да имаме статични функции в класовете. Това са функции, които не са обвързани с обекта, НЕ могат да променят член-данните му и следователно не могат да бъдат const. За извикването им не ни трябва инстанция на класа.

## Задача първа
Да се напише клас SwapCounter, който предоставя функция swap и начин по който можем да разберем колко пъти функцията е извикана.
Да се използва класа за да се направи сравнение между операциите по разместване на елементите които алгоритмите BubbleSort и InsertionSort извършват.

## Задача втора
Да се реализира клас `KeyValueCache` представляващ кеш от стойности които достъпваме чрез ключове. Ключовете са числа между 0 и 99. Стойностите са произволни числа. Да се реализират функции:
* insert(key, value) - добавя стойност `value` за ключ `key`
* get(key)           - взема стойността на key

При създаването на кеша стойността на всички ключове е 0.

Използвайте кеша за да реализирате функция, която връща n-тото число на фибоначи (за n < 100).
Функцията пази кеша в себе си. Всеки път, когато имаме числото, функцията директно го прочита от кеша. В противен случай функцията го пресмята и го добавя в кеша.

## Изключения
Във всяка една програма могат да се появят логически грешки или грешки по време на изпълнение на програмата. един пример за такава ситуация е ```operator[]``` за класът ```String```, който написахме последния семинар.

```cpp
char String::operator[](size_t index) const
{
	assert(index <= size);
	return data[index];
}
```
В случая грешката, която може да се случи е очевидна - можем да подадем индекс, който е извън рамките на буфера. Как се справяме с подобни грешки? В случая е използван ```assert``` - ако грешката възникне програмата приключва. Но такива грешки могат да възникват по-често отколкото си мислим. Струва ли си при първата такава да прекратяваме програмата?

В повечето сценарии предпочитания начин да се справим с грешки е да използваме изключения.

## Кога точно използваме изключения
В езика С (и не само) грешките се обработват или чрез връщане на стойност, която представлява код за грешка или чрез променяне на стойността на някоя глобална променлива, която извикващия функцията може да прочете. И в двата случая зависи от извикващия функцията да провери дали има грешка и да реагира на нея.

Ако не реагираме програмата ни може да продължи с некоректни данни (или да сегментира).

Изключенията се появяват със С++ и имат следните свойства:
* Изключението ни принуждава да се справим с проблема.
* Изключението отива до функцията която може да се справи с него. Междинните функции оставят изключението да продължи.
* Изключенията използват механизъм наречен stack unwinding, който унищожава всички обекти в скоупа по добре дефинирани правила.

Нека разгледаме как се хвърля изключение:

```cpp
char String::operator[](size_t index) const
{
	if(index >= size);
        throw std::out_of_range("Index out of range!");
    
	return data[index];
}
```

След като се хвърли изключението то ще започне да търси първата функция от стека, която може да се справи с него.

А как може функция да се справи с изключение? С изключения се справяме използвайки try-catch блокове:

```cpp
#include "String.h"
#include <iostream>

int main()
{
	String str = "Hello";

	try
	{
		std::cout << str[100];
	}
	catch (const std::out_of_range& e)
	{
		std::cout << e.what();
	}
}
```
Каква е идеята тук? Кодът в try се изпълнява нормално. Ако не хвърли изключение - супер. Ако хвърли се изпълнява кодa в catch. В случай, че имаме много изключения, които могат да се хвърлят можем да имаме няколко catch блока.

```cpp
try
{
    std::cout << str[100];
}
catch (const std::out_of_range& e)
{
    std::cout << e.what();
}
catch (const std::exception& e)
{
    std::cout << "STD exception" << e.what();
}
catch (...)
{
    std::cout << "Unknown exception";
}
```
Би било добре да си зададем въпроса какво е std::exception или std::out_of_range? Това са класове. Ролята на тези класове е да бъдат хвърляни като грешки и след това хващани. 

Това означава, че можем да хвърляме като грешки и наши класове? Можем. В някакъв смисъл има вероятност да се хвърли обект, който не предполагаме дори, че съществува. Синтаксисът `catch(...)` хваща всичко. Разбира се, ако се хвърли out_of_range той ще бъде хванат от първия catch блок.

Ако не се намери подходящ catch блок програмата терминира.

Нека разглидаме още един пример за да стане напълно ясно:
```cpp
#include <iostream>

void bar()
{
	throw std::exception("Oh no...");
}

void foo()
{
	bar();
}

int main()
{
	try
	{
		foo();
	}
	catch (const std::exception& e)
	{
		std::cout << e.what();
	}
}
```
В случая foo извиква bar която хвърля изключение. foo не знае как да се справи с него (няма try-catch блок) и го предава на main. Той от друга страна знае как да се справи с него и на стандартния изход се извежда очакваното съобщение.

## Задача трета
При използване на класа `String` можем да достигнем до следния случай:
```cpp
string str1 = "Hello";
string str2 = "Hello';
```
В този случай двата стринга пазят памет с една и съща стойност. В класическата имплементация на string, използвана от стандартната библиотека на C++ това поведение е по подразбиране. Всеки низ пази своята памет.

Съществува алтернативна имплементация, която ни ограничава, но е по ефикасна от към памет. Имплементацията забранява промяната на низовете, но низовете с еднаква стойност споделят паметта си.

Този начин на реализация на класа `String` използва идеята за `StringPool` - обект, който разпределя паметта между инстанциите на класа `string`. 

Да се реализира клас `ImmutableString`, който реализира описаната схема за работа с паметта. За тази цел ще се наложи да реализираме клас `StringPool`, който да пази паметта.

Класът `StringPool` съдържа следния публичен интерфейс:
* getString(const char*) - връща указател към низа ако съществува. в противен случай го създава и връща указател към него
* removeString(const char*) - сигнализира, че един от потребителите на низа е спрял да го използва. Ако низа няма никакви потребители той се изтрива.

Класът няма горна граница за низовете които може да поддържа. 

Решение на задачата [тук](../../Seminar-IS/Seminar08/ImmutableString/).