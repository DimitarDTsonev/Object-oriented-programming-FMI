# Девети семинар по обектно ориентирано програмиране СИ

## Нива на сигурност при изключения
### No throw guarantee 
Можем да гарантираме за операциите, че ще успеят дори в ситуация на грешка. Ако грешка се случи тя ще бъде обработена вътрешно и потребителите на кода няма да разберат за нея.

Пример за такива функции обикновено са `move` конструкторите. Функция, която не хвърля грешки, се декларира като `noexcept`.

```cpp
int f() noexcept
{
    return 2 + 3;
}
```
Също функции като `size()`, `empty()`, `capacity()` и тн имат `no throw guarantee`.

### strong exception safety
Възможно е да се хвърли грешка, но дори да се случи обектът няма да промени състоянието си.
Пример за такава функция е функцията `push_back` от `std::vector`. При добавяне на 10 елемента проваленото добавяне на единадесети няма да повлиае на добавените елементи.

### Basic exception guarantee
Ако функцията хвърли изключение програмата е във валидно състояние. Няма отечки на памет и всички инварианти на обектите са изпълнени.

### No exception guarantee
Не обещаваме нищо - ако програмата хвърли грешка можем да не сме във валидно състояние.

## Преговор на value categories + move semantics.

## Задача първа
Да се реализира клас `UniquePtr` който представлява указател към някакъв обект от тип `A`. Класът изцяло притежава обекта. 

Да се реализират:
* `operator->` и `operator*` помагащи ни да достъпим стойността на умния указател по начина по който бихме го направили ако беше нормален указател.
* Функция `get()` която връща указател към обекта, с който работим.
* Функция `reset()` която приема нов обект и унищожава стария.
* Функция `release()` която освобождава обекта.

Помислете дали:
* Имаме нужда от `copy semantics` и `move semantics`. 
* Ако решим да не реализираме копиране можем ли напишем функция от вида `void foo(UniquePtr p)`?

## Задача втора
Да се напише клас който работи с ученици. Един ученик се описва с име и вързаст. Да се реализира следния интерфейс:

* push - Добавя ученик на първия свободен индекс
* pushAt(index) - Добавя ученик на индекс.
* removeAt(index) - премахва ученик на подаден индекс 
* setAt(Student, index) - дава стойност на ученик на подаден индекс
* getNumberInClass - взема номера на ученика в класа.
* containsAt(index) - проверява дали има ученик на индекса

При премахване на ученик номерата на останалите ученици се запазват. Номера на ученик е индекса му в наредбата. Класът, представляващ ученик, няма конструктор по подразбиране.
