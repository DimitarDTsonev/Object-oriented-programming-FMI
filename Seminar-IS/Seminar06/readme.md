# Шести семинар по обектно ориентирано програмиране - информационни системи

## Разделна компилация.
Компилацията на един С++ проект е сложен процес. Все пак, най-просто казано, целта ни е от един (или повече) файла, съдържащи код написан на С++, да създадем изпълним файл, който представлява нашата програма. Изпълнимите файлове (.exe, .out) са файлове, които операционната система знае как да зареди и изпълни. Това са нашите програми. Но как точно се създават те?

Можем да разбием процесът на създаване на програма на следните стъпки:
1. Preprocessor - обработват се всички препроцесорни директиви
2. Compilation  - С++ се свежда до assembly и от там до object file (.obj, .o)
3. Linking

## Какво представлява препроцесора
Нека първо разгледаме какво представляват препроцесорните директиви. Тези, които ние ще разгледаме, са:
* #include
* #define
* #ifndef

Препроцесорните директиви започват със символа #. 

## include

Неформално - добавя файл в нашия файл.

Нека имаме следните два файла:
![](media/include.png)

След изпълняването на препроцесора файла `src.cpp` би изглеждал по следния начин:

![](media/preprocessed.png)

От уводния курс по програмиране познаваме директивата `#include`. Използвахме я в следния контекст `#include<iostream>`. В случая обаче не използваме символите `<>` а използваме `""`. И двата синтаксиса правят едно и също - добавят някакъв файл към нашия файл. Разликата е как търсят този файл:

* Използвайки синтаксиса `#include"..."` търсим файла по подаден път.
* Използвайки синтаксиса `#include<...>` търсим файла в някоя от предварително зададените директории в която се съдържат нашите библиотеки.

Наистина, би било неудобно да пишем всеки път дълги пътища за да намираме файловете си. Можем да зададем така наречените include директории в които нашия компилатор да търси файловете. Стандартните библиотеки като `iostream`, `cmath` и тн. се намират в директории, които са предварително известни за компилатора. Ако искаме същото поведение с наши библиотеки можем да добавим наша директория към include директориите.

Можем да подаваме всякакви файлове използвайки `#include`, но скоро ще видим, че това не е особено добра идея.

## define
Чрез препроцесорната директива `#define` дефинираме така наречените макрота (macros). Те не са нищо повече от замяна на един текст в друг.
Синтаксис:

```cpp
#define identifier replacement
```

нека разгледаме следния файл:

```cpp
#define FIVE 5

int main()
{
    return FIVE;
}
```

След препроцесването файлът изглежда така:

```cpp
int main()
{
    return 5;
}
```

Това е изключително удобно в някои случаи - можем да даваме други имена на неща, можем да "симулираме" глобални константи (които обаче не заемат памет). И разбира се, ако не внимаваме може и да счупим нещо

```cpp
#define true false
```

Можем да подаваме и аргументи на написаните от нас макрота:
```cpp
#define SQUARE(x) ((x) * (x))
int result = SQUARE(5);
```

Можем също така просто да дефинираме някакви макрота без стойност:

```cpp
#define VERSION_1_1
```

## #ifndef
Препроцесорната директива #ifndef проверява дали макро е дефинирано.
Това може да бъде полезно в много случаи.

```cpp
#ifndef VERSION_1_1
    std::cout << "Not running on version 1.1";
#else
    std::cout << "Running on version 1.1";
#endif
```
Както виждаме от примера, трябва да завършим проверката с `#endif`. Също така имаме възможност да окажем какво се случва, ако макрото е дефинирано.

## Компилация - но накратко!
След като препроцесора е свършил работата си, идва момента на компилацията. В резултат на нея се получават един (или повече) обектни файлове. Обектните файлове представляват машинен код, метаинформация за кода и символи (имена на функции, променливи, класове и тн.).

Компилацията е наистина сложен процес, включващ много оптимизации, анализи и стъпки, които често остават скрити за нас. Най-честата схема, по която се случва компилацията е, че C++ кодът се превръща в код на езика Assembly. Assembly е език, който е близък до машинния код. От там изходът се превръща (чрез асемблер) в машинен код (.obj, .o).

В дъното на всичко е превръщане на един текстов файл (.cpp) в един двоичен файл (.obj). 

Ако пишем всичко в един .cpp файл, цялото това превръщане ще стане **твърде бавно** (и не говорим за забавяне от порядъка на минути). 
Но защо да пишем всичко в един С++ файл? Все пак големите проекти могат да се разбият на много компоненти. Не можем ли да разбием кода си на много cpp файлове?

Можем (и е добре да го правим). Точно от там идва термина **разделна компилация.** Какво е предимството? Нека си представим проект, който има 2000 cpp файла. Нека също те са компилирани и имаме нужда да направим промяна в един от тях. Тогава ще се компилира **единствено този файл** и останалите файлове няма да се променят! Това прави компилацията **в пъти** по-бърза. Никой няма време да чака ден да се компилира промяна на 2 реда.

Твърдението, че единствено променения файл ще се компилира звучи много хубаво. То е истина ако предпоставката, че единствено този файл е промененя е истина. Ако променяме файл, който е инклуднат в други файлове, то и те се променят въпреки, че не ги променяме пряко.

Споменахме, че разбиваме проекта си на различни компоненти. Тези компоненти независими ли са, или една компонента може да използва функции/класове и т.н. от друга?

## Разделяне на .h и .cpp файлове
Тук идва тънкостта на разделната компилация. Стандартно, всяка компонента представлява двойка от `.h` и `.cpp` файл. Ние знаем какво е `.cpp` файл. Файловете с разширение `.h` от `header` или на български заглавни файлове **съдържат единствено дефинициите на функциите, класовете и т.н. които ще използваме.** В `.cpp` файловете се съдържа имплементацията на тези функции/класове.

Нека под *символ* разбираме всяка единица която може да се именува - променливи, функции, класове, константи, enum...

Неформално можем да си мислим следното:
Заглавните файлове **обещават** че някакъв символ съществува. Реализацията на този символ се намира в друг `.cpp` файл и се **компилира отделно.** 

Тоест, ако искаме да използваме символ от друг компонент, е достатъчно включим заглавния файл на компонента с #include и да го реализираме в cpp файла му.

## Как се намират символите? Linking
Чрез `.h` файловете давахме обещание, че някакъв символ съществува. Това обещание обаче трябва някой ден да се случи - все пак накрая всичко завършва в един изпълним файл. След като се компилират отделно всичси `.cpp` файлове получаваме няколко `.obj` файла. В някои от тях има обещания за съществуването на някакви символи. Работата на linking частта е да свърже обещаните символи с реализациите им. Тоест ако `A.cpp` очаква `void f()`, който е в `B.cpp` (и е обещан от `B.h`), то линкърът ще направи тази връзка. 

След като връзките биват изградени получаваме така желания изпълним файл.

# pragma once
Има опасност да вмъкнем един и същ `.h` файл два пъти. Това би довело до грешка, понеже тогава ще станат две декларации, които са едни и също. За да избегнем това поведение използваме препроцесорната директива `#pragma once`. Пишем я в началото на всеки `.h` файл.

## Агрегация и композиция

### Композиция
- отношение, при което вътрешния клас (B) няма предназначение в системата извън външния (A)
- A "притежава" B
- А отговаря за жизнения цикъл на B
- комания <- акаунти

```cpp
class A 
{
    B obj;
}
```
### Агрегация
- отношение, при която вътрешния клас (B) може да съществува независимо от външния (A)
- A "използва" B
- A не отговаря за жизнения цикъл на B
- комания <- хора


```cpp
class A 
{
    B& obj;
}

//или

class A 
{
    B* obj;
}

```

## Задача първа
Да се напише клас, който представлява събитие. Събитие се характеризира с:
* Име - дължина до 20 символа.
* Дата на събитието - Date от лекции
* Начален и краен час на събитието - класът Time от семинари.

## Задача втора
Да се напише клас за работа с крайно множество от събития (най-много 20). Класът трябва да съдържа:
* Добавяне на събитие
* Намиране на най-дългото събитие
* Премахване на последното събитие
* Премахване на събитие по име.
* Приемане на дата и връщане на максималния брой събития, които може да се посетят в този ден. (за да се посетят 2 събития, те трябва да не се пресичат).

## Голяма четворка
В уводния курс разбрахме, че ако не подадем по референция на него му се прави копие. Това важи както за примитивните типове от данни така и за класовете и структурите създадени от нас. Това е и причината на константните референции да се обръща специално внимание - при големи обекти копието е скъпо. Но как точно става копието при създадени от нас класове? Възможно ли е да имплементираме наша логика за копиране?

Да. С копирането на един обект в някакъв смисъл започва живота на друг, та логиката за копиране е естествено да се описва в конструктор. Когато създаваме клас или структура следните четири се генерират автоматично за нас:

* Конструктор по подразбиране
* Копиращ конструктор - съдържа логиката за копиране на обект
* Оператор за присвояване - съдържа логиката за присвояване на обект
* Деструктор

С конструктора по подразбиране и деструктора се занимавахме подробно миналия път.

```cpp
class Entity
{
    A a;
    B b;
    C ;
};

int main()
{
    Entity e; // Конструктор по подразбиране.
    Entity e1(e); // Копиращ конструктор.
    e = e1; // Оператор за присвояване.
} // Деструктор на e и e1.
```

### Как работят дефинираните от компилатора функции
Всяка една от тези функции **извиква 'рекурсивно' същите функции върху член-данните**.


### Конструктор за копиране - синтаксис и пример
В конструктора за копиране държим логиката по копиране на обекта (както името може да подскаже).
Нека разгледаме следния пример:

```cpp
#include <iostream>

class Entity
{
private:
	int x;
public:
	Entity(int x) : x(x) {}

	int get() const
	{
		return x;
	}
};

void f(Entity e)
{
	std::cout << e.get();
}

int main()
{
	Entity e(12);
	std::cout << e.get() << std::endl;
	f(e);
}
```
В случая на обекта Entity му се прави копие. копиращия конструктор отговаря за това копие а той е автоматично генериран от компилатора. Очакваното поведение е да копира всички член данни. В случая имаме една променлива от тип int (и знаем как се копират тези променливи). Следователно е ясно какво ще стане тук - ще се изведе два пъти 12.

Нека се опитаме (за примера) да променим малко кода. Нека в Entity класът добавим следния публичен ред:
```cpp
// конструктор за копиране
Entity(const Entity& other) : x(2 * other.x) {}
```

Това е конструктор, който приема константна референция към друг обект. **Обектът, който се създава копира подадения по референция обект!**. Все пак това е С++, та имаме контрол над това как се случва копирането. Какво ще изведе кодът след като добавихме този ред?

Ще изведе 12 и 24. След имплементирането на наша логика за копиране новосъздадения обект има стойност **два пъти по-голяма от обектът, който използва за да се копира.**

### Оператор за присвояване - синтаксис и пример.
В оператора за присвояване се съдържаа логиката за присвояване на обект (какво става когато напишем e1 = e2 където и двата обекта са вече изградени).

```cpp
#include <iostream>

class Entity
{
private:
	int x;
public:
	Entity(int x) : x(x) {}

	// конструктор за копиране
	Entity(const Entity& other) : x(2 * other.x) {}

	int get() const
	{
		return x;
	}
};

int main()
{
	Entity e(12);
	
    // Тук се използва оператор за присвояване, но се създава нов обект.
    // В случая се вика копиращ конструктор. Това е еквивалентно на 
    // Entity e1(e).
	Entity e1 = e;

	Entity e2(14);

    // Колко ще е стойността на e2.get()?
	e2 = e;

	std::cout << e.get() << " " << e1.get() << " " << e2.get();
}
```

В случая отново ще се случи очакваното - e има стойност 12, e1 има стойност 24 заради копиращия конструктор а e2 има стойност 12.
Можем ли да направим наша логика за присвояване? Да - нека добавим следния публичен ред в класа Entity:

```cpp
Entity& operator=(const Entity& other)
{
	x = other.x / 2;
    return *this;
}
```

Сега при присвояване обектът от лявата страна ще има два пъти по - малка стойност от десния. Нека забележим, че ```operator=``` връща референция към текущия обект. Това е очаквано, най-малкото искаме да можем да правим неща като ```e1 = e2 = e3```. Това са две изпълнения на ```operator=``` и за да се изпълни второто то има нужда от референция (която първото изпълнение връща).

### Проблем с генерираните от компилатора функции
Нека разгледаме следния пример от последния семинар:
```cpp
#include <iostream>
#include <cstring>

class Entity
{
private:
    char* label;

    void free()
    {
        delete[] label;
    }
public:
    Entity() : label(nullptr) {}

    Entity(const char* c) 
    {
        size_t len = strlen(c);
        label = new char[len + 1];
        strncpy(label, c, len);
        label[len] = '\0';
    }

    const char* getLabel() const
    {
        return label;
    }

    ~Entity()
    {
        free();
    }
};

int main()
{
    Entity e("label value");
    Entity e1(e);
}
```
Следния пример ни води до проблем. Къде е проблема???
* Създава се обект е - за него се заделя памет
* Създава се обект е1 - на него му се вика конструктор за копиране
* Конструктор за копиране рекурсивно копира всички член данни. Тук има една член данна.
* Сега e1::label е копие на e::label
* Два копирани указателя имат различен адрес в паметта, но **сочат към една и съща памет**
* Първо се вика деструктора на е - той трие паметта към кояно сочи e::label
* След това се вика деструктора на e1 - той трие паметта към която сочи e1::label, но **тя вече е изтрита!**. Това води до проблем.

Къде е проблема тук? Проблема е, че очакваме **друго поведение при копиране на указателя**. Това е така нареченото **shallow copy**. Вече знаем как да направим наша логика по копиране - нека оправим проблема:

```cpp
Entity(const Entity& other)
{
    label = new char[strlen(other.label) + 1] {};
    strcpy(label, other.label);
    // Ако имаме други член данни трябва да се погрижим и за техните стойности!!!
}
```
сега вече не правим копие на указателя а заделяме нова памет. Кодът обаче има още един проблем:

```cpp
int main()
{
    Entity e("label value");
    Entity e1(e);

    e = e1;
}
```
Това чупи програмата ни, но защо? Става нещо подобно както с конструктора. Отново се случва неправилно копиране на указателя и го трием два пъти. 

Проблема решаваме по следния начин:

```cpp
Entity& operator=(const Entity& other)
{
    if (this != &other)
    {
        free();
        label = new char[strlen(other.label) + 1] {};
        strcpy(label, other.label);
    }
    return *this;
}
```

Нека хвърлим малко светлина:
* Проверката ```this != &other``` ни спасява да не напишем нещо от сорта на ```e = e```. Сравнява се **по адрес а не по стойност** - ```this``` е указател &other връща адрес.
* free() - преди да заделим място за новата стойност трябва да изтрием старата. Иначе става отечка.
* Следващите два реда трябва да се изнесат във функция. Тази логика я имаме в копиращия конструктор както и в оператора за присвояване - нека не дублираме код.
* return *this - връща референция към текущия обект.

Финалната версия е качена в `big-four.cpp`. 

При липсата на външен ресурс често не разписваме тези функции - генерираните от компилатора ни вършат достатъчно добра работа.
Когато работим с такъв обаче е добре да разпишем четирите функции. Също следната конвенция важи:
* Логиката за изтриване **се извежда във отделна функция**
* Логиката за копиране **се извежда в отделна функция**
* Когато копираме **трябва да се порижим за всички член данни не само за динамичната памет**