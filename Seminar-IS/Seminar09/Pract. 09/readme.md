## Задачa 1 - Foodpanda
Трябва да се създаде система за обработка на поръчки.

Създайте клас, който описва ресторант. Всеки ресторант има:
- име (с максимална дължина 25 символа);
- списък от продукти (с произволна дължина, която се подава в конструктора);
	* всеки продукт е низ с произволна дължина
- Поддържаме добавяне на продукт
- Поддържаме и метод за получаване на поръчка
  
Създайте клас, който описва поръчка. Всяка поръчка има:
- име на ресторанта, за когото е
- брой продукти
- списък с продуктите.

Ако в поръчката има продукт, който ресторантът не предлага, се хвърля грешка. <br />
В противен случай връща времето за доставка (време в минути, вие избирате каква точно да е логиката) <br />

Създайте клас Foodpanda, който има списък с ресторанти (отново с произволна дължина, която се задава в конструктора) и който прочита поръчки от конзолата. <br />
Класът намира за кой ресторант е поръчката, ако има такъв, в противен случай изписва, че поръчката е невалидна, понеже такъв ресторант не съществува. <br />
Ако ресторантът съществува му я изпраща. <br />
- Направете метод за добавяне на нови продукт/и в даден ресторант/и.
- Направете метод за добавяне на нови ресторанти във Foodpanda.
  
:warning: За всеки от класовете реализирайте нужните конструктори(+ move семантики) и функционалности.

## Задачa 2 - MyVector
Напишете ваша имплементация на `MyVector` `(+ big six)`, засега нека работи само с `int`. След като вземем `template-и` ще го модифицираме

Публичен интерфейс на класа:
 - `pushBack(element)` - добавя елемент в края 
 - `pushBack(element&&)` - добавя елемент в края `(с move)`
 
 - `popBack()` - премахва елемента в края на колекцията. Ако колекцията е празна, се хвърля изключение
 - `at(index)` - връща елемента на позиция `index` и за четене, и за промяна. Ако `index` е невалиден, се хвърля изключение
 - `front()` - връща референция към първия елемент и за четене, и за промяна. Ако колекцията е празна, се хвърля изключение
 - `back()` - връща референция към последния елемент и за четене, и за промяна. Ако колекцията е празна, се хвърля изключение
 - `empty()` - връща дали колекцията е празна
 - `size()` - връща броя на елементите в колекцията
 - `capacity()` - връща колко е текущият заделен капацитет
 - `reserve(newCapacity)` - ако `newCapacity <= capacity`, функцията не прави нищо. Ако е повече - заделя се нова памет и елементите се копират. `size` не се променя
 - `shrinkToFit()` - изчиства неизползваемата памет. След извикването `size == capcity`
 - `clear()` - изтрива всички елементи от колекцията. Заделената памет не се изтрива
 - `insert(element, index=0)` или `insert(element&&, index=0)` - добавя елемент на позиция `index`. Ако `index >= size`, елементът да се добави в края. Ако `index < 0`, елементът да се добави в началото. Ако не е указано кой е `index-ът`, той е 0 `(с и без move)`
 - `insertRange(MyVector, index=0)` или `insertRange(const int*, int size, index=0)` - вмъква колекция от елементи, започвайки от позиция `index`, останалите елементи се изместват надясно. Ако `index >= size`, колекцията да се добави в края. Ако `index < 0`, колекцията да се добави в началото. Ако не е указано кой е `index-ът`, той е 0
 - `erase(element, allOccurences=false)` - изтрива първото срещане на елемент. Ако за втори параметър се подаде `true`, се изтриват всички срещания
 - `resize(newCount)` или  `resize(newCount, value)` - променя САМО броя на елементите. Ако `newCount==count`, функцията не прави нищо. Ако `newCount<count` - броят на елементите в колкцията се намаля до `newCount`. Ако `newCount>count` - броят на елементите в колкцията се увеличава до `newCount`. Новите елементи имат стойност `value`. Ако `value` не е подадено, се задават с `default-ната` стойност за типа

 Предефинирайте операторите:
 
 - `[index]` - връща елемента на позиция `index` и за четене, и за промяна. Ако `index` е невалиден - оставете `undefined behaviour`
 - `==` - `true`, когато броят на двете колекции е равен и всички двойки елементи на позиция `i` са равни
 - `!=`
 - `<`, `<=` - `lhs<rhs(или <=)`, lhs лексикографски е преди rhs
 - `>`, `>=` - `lhs>rhs(или >=)`, lhs лексикографски е след rhs	
