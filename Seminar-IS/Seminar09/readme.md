# Девети семинар по обектно ориентирано програмиране - информационни системи

## Move semantics

### Value categories
Всеки израз в С++ има **тип** и принадлежи на **точно една категория** (value category). Тези категории са основите за правилата, които компилатора е длъжен да спазва когато създава, копира **или премества** временни обекти по време на оценка на израз.

Ще разгледаме двата основни типа категории:
* lvalue изразите имат адрес, който програмата ни може да достъпи. Примери за lvalue изрази са имената на променливи, елемент на масив, член-данните на клас и т.н.

* (p)rvalue изразите нямат адрес, който е достъпен от нашата програма. Примери за такива изрази са литерали, извиквания на функции, които не връщат референции, и временни обекти, които са създадени по време на оценяване на израза.

Исторически имената идват от факта, че lvalue може да стои от лявата страна на оператор= а rvalue може да стои от дясната.

```cpp
int main()
{
    // Променливата i е lvalue
    // Литерала 7 е (p)rvalue
    int i = 7;

    // Неправилна употреба
    7 = i;
}
```

Lvalue изразите могат и да не са променливи:

```cpp
int x;
int& get()
{
    return x;
}

int main()
{
    get() = 4; // ОК, get връща lvalue

    int i = 0;
    int j = 10;

    // ОК тернарния оператор връща lvalue.
    ((i < 3) ? i : j) = 7;

    // i + j не е lvalue - грешка
    (i + j) = 4;

}
```
### lvalue референции
lvalue референциите всъщност са стандартните референции с които сме запознати.

```cpp
void f()
{
    int x = 10;
    int& y = x;
}
```
Те са просто друго име на обект.

### rvalue референции
Една интересна особеност на `rvalue` изразите е, че се отнасят към обекти, които са временни (скоро ще бъдат изтрити още наречени xvalues). Би било полезно да знаем дали променливата, която се връща от някой израз, връща временна променлива или не и да го пренапишем по различен начин ако случая е такъв.

До С++11 референции към константна rvalue са възможни, но те не могат да изменят обекта, т.е.

```cpp
String getName() {
	return "Pesho";
}

const String& name = getName(); //ok
String& name = getName();       //not ok
```

При C++11 се въвежда нов тип референция, а именно rvalue референцията, която позволява референция към rvalue. С други думи, rvalue референциите са идеалният начин за разпознаване дали една стойност заема място в паметта или не. За разлика от lvalue референциите, те се пишат с &&.

```cpp
int i = 42;
int &r = i; // ok: r refers to i
int &&rr = i; // error: cannot bind an rvalue reference to an lvalue

int &r2 = i * 42; // error: i * 42 is an rvalue
const int &r3 = i * 42; // ok: we can bind a reference to const to an rvalue
int &&rr2 = i * 42; // ok: bind rr2 to the result of the multiplication
```

Можем да кастнем lvalue към xvalue (което е rvalue) и да присвоим кастнатата стойност към rvalue референция
```cpp
int x = 5;
int&& xRRef = x;   //Error: rvalue reference cannot be bound to an lvalue

int&& xRRef = std::move(x);  //Ok
int&& xRRef = (int&&)(x); //  Ok
```

Функцията `std::move(T)` прави точно този каст към rvalue референция.

С какво ни помагат този тип референции? Вече разполагаме с апарат, който точно ни казва към коя категория принадлежи подадения аргумент на функция:

```cpp
#include <iostream>

void f(int& x)
{
	std::cout << "Lvalue reference" << std::endl;
}

void f(int&& x)
{
	std::cout << "RValue reference" << std::endl;
}

int main()
{
	int x = 10;
	f(x);
	f(10);
}
```

## Move конструктор и move assignment оператор
При конструктора за копиране приемахме константна lvalue референция.

При move конструктора приемаме **неконстантна rvalue референция**. В някакъв смисъл конструктора за копиране ни казваше **как се копира обекта**. Move конструктора ни казва **как обекта се премества**. Какво означава да преместим обект?

Когато създаваме обект от обект, който е на път да се изтрие, ние можем **да откраднем ресурсите му** и **да го оставим в състояние, което няма да попречи на изтриването му.** При примитивните типове данни това е просто копиране, но когато работим с динамична памет можем да откраднем тази памет.

Пренасочваме нашите указатели към нея и пренасочваме другите указатели към `nullptr`.

```cpp
String::String(String&& other)
{
	data = other.data;
	other.data = nullptr;

	size = other.size;
	other.size = 0;
}
```

В случая пренасочваме нашия указател към вече заделената памет и пренасочваме чуждия към `nullptr` (за да не я изтрие деструктора на other).

```cpp
#include "String.h"
#include <iostream>

int main()
{
    String str;
    str += "Hello";

    // Move constructor called!
    String str1 = std::move(str);
}
```

Също така можем да имаме и move operator=

```cpp
String& operator=(String&& other)
{
    if(this != &other)
    {
        free();

        // В контекста на operator=
        // other се третира като lvalue референция (има място в паметта).
        // Трябва да направим още един каст.
        move(std::move(other));
    }
    return *this;
}
```

Функцията move изглежда по следния начин:
```cpp
void String::move(String&& other)
{
    data = other.data;
    other.data = nullptr;

    size = other.size;
    other.size = 0;
}
```

## Автоматично генерирани move конструктор и operator=

## Задача първа
Да се имплементират move конструктор и move operator= за класът String.

## Динамични масиви. Колекции от указатели.
