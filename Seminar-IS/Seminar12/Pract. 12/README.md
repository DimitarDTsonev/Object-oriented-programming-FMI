## Sets - класове

Разглеждаме абстрактен базов клас `Множество`, което е съставено от стрингове. Едно множество задължително трябва да има оператор за индексиране, който връща булев резултат дали подадения като аргумент елемент принадлежи на множеството.

Наследници на това множество са следните конкретни класове:

- `Крайно множество` - елементи се подават като масив в конструктора.

- `Множество-интервал` – в конструктора се подават два елемента – граници на интервала. Всички елементи на множеството трябва да са в интервала **(затворен интервал).**

- `Множество по критерий` – в конструктора се подава **предикат (булева функция)**, който определя дали даден елемент принадлежи на множеството. По-надолу в описанията на множествата има различни видове критерии. Помислете как да направите това множество, така че да не се интересувате какъв е критерият.

- `Сечение на множества` – в конструктора се подават едно или повече множества. Създаденият обект (сечение) съдържа даден елемент, когато този елемент се съдържа във всяко от подадените множества.

- `Обединение на множества` - в конструктора се подават едно или повече множества. Създаденият обект (обединение) съдържа даден елемент, когато този елемент се съдържа в поне едно от подадените множества.

- Добавете метод за добавяне на множество към `Обединение` и `Сечение`

## Sets - файлова система

Реализирайте програма, която прочита от текстов файл множество от символни низове – имена на **двоични** файлове. Всяко име е разположено на **отделен ред** и съдържа валидно име на двоичен файл в съответната файлова система. Съдържание на всеки двоичен файл:

- В началото на всеки файл има едно 32-битово число - **stringsCount**
- След тях има **stringsCount** на брой стринга. Всеки стринг е представен по следния начин: </br>
   {число(uint8_t) **addType**}{число(int) **stringLength**}{**stringLength** символа} 

Стойността на **addType** разглеждаме като поредица от битове, която определя какъв тип множество ще определят тези низове и как ще се добави то към резултата. Най-младшите два бита определят начина на добавяне, а най-старшите три бита определят типа на множеството.

За начин на добавяне разглеждаме три стойности:
- `0` – съответното множество замества резултата, без значение на предишни прочетени множества
- `1` – съответното множество се добавя като обединение към получения до момента резултат
- `2` – съответното множество се добавя като сечение към получения до момента резултат

За тип на множествата разглеждаме следните стойности:
- `0` – Файлът описва **крайно** множество. **Елементите са всичките низове от текущия файл**.
- `1` – Файлът описва **множество - интервал**. В този случай **stringsCount задължително трябва да е 2**. Двата последващи низа определят интервала.
- `2` – Файлът описва **множество по критерий**. Негови елементи са **низовете, които съдържат някой от подадените stringsCount низа в себе си**.
- `3` – Файлът описва **множество по критерий**. **Негови елементи са низовете, които са конкатенация на някои два от подадените низове**.
- `4` – Файлът описва **сечение на множество интервали**. **stringsCount задължително трябва да е четно число**. Всеки два последователни низа във файла описват един интервал и **резултатното множество е сечението им**.
- `5` – Файлът описва **обединение на множество интервали**. **stringsCount задължително трябва да е четно число**. Всеки два последователни низа във файла описват един интервал и **резултатното множество е обединението им**.

!!! За множеството от първия файл се игнорира начина му на добавяне. То става начално множество 

От данните във всеки файл създайте съответното множество. Това множество добавете към резултатно множество, съгласно описаното във файла – замяна, обединение и съответно сечение с него. Започвате да прилагате операциите от втория файл към първия, след това от третия към резултата и така нататък.

Накрая въведете от клавиатурата текст до край на файл. За всеки от редовете му проверете дали се съдържа в резултатното множество и изведете броя на тези редове.L
