# Пети семинар по обектно ориентирано програмиране

## Деструктори
Деструктора е функция, която се извиква при унищожаване на обекта. Често деструктора се използва за освобождаване на някакъв външен ресурс. При статични обекти унищожаването става когато приключи живота на обекта (най-често в края на скоупа), при динамични при извикване на `delete`. Примери за това кога и как се извиква деструктор можете да намерите в `destr-examples.cpp`.

Синтактично, декларираме деструктор по следния начин:
```cpp
class Entity
{
public:
    ~Entity()
    {
        // destructor!
    }
};
```
За разлика от конструкторите, деструкторът е единствен. Той нито има нужда от аргументи нито връща стойност.

## Пример за конструктори и деструктори в класове използващи динамична памет.
Може да видим още един пример за конструктори и деструктори в `dyn-memory-class-example.cpp`

## Капсулация.
Споменахме, че член данните могат да бъдат декларирани като `private`. Това ги прави невидими за външния свят. Със същия успех можем да декларираме и член функции като `private`. Скриването на информацията ни помага да имаме по-добра **капсулация**. Капсулацията е един от основните принципи на обектно ориентираното програмиране. 

Тя налага разбиването на един клас на интерфейс и имплементация. Интерфейсът представлява набор от операции, които потребителят може да изпълнява свободно по начин, който не "бърка" в имплементацията. Понякога искаме потребителите да нямат достъп до всички член-данни и методи на даден клас. Това е така, защото тяхната промяна може да доведе до неочаквано поведение на нашата програма. Принципът за капсулация ни помага като позволява да определим кои методи и атрибути може да използват потребителите на нашия клас.

## Селектори и мутатори.
Когато член данните са декларирани като `private` те са скрити от външния свят, но това не означава, че не можем да ги променяме използвайки член функции.

```cpp
class Entity
{
private:
    int x = 0;
public:
    void set(int argx)
    {
        x = argx;
    }

    int get() const
    {
        return x;
    }
};

int main()
{
    Entity e;
    // std::cout << e.x; - Грешка, х е private!
    e.set(10);
    std::cout << e.get(); // Извежда 10
}
```

Какъв е смисъла да скриваме член данните и да ги променяме през функции? Смисъла е, че по този начин можем да наложим някакви ограничения за стойностите им. Възможно е не всяка стойност, която типът може да приема, да е валидна стойност. Члез `set` функциите налагаме ограничения като можем да не допуснем някоя стойност.

## Задача първа 
Реализирайте клас Time, който ще се използва за работа с часове (13:05:45). Вашият клас трябва да има следния интерфейс:

* Подразбиращ се контруктор, който създава часа на 00:00:00.
* Конструктор, който приема три параметъра - час, минути и секунди.
* Член-функция, която връща оставащото време до полунощ.
* Член-функция, която увеличава часа с 1 секунда.
* Член-функция, която връща дали е време за вечеря. В рамките на задачата време за вечеря е между 20:30 и 22:00.
* Член-функция, която приема друг обект от тип Time и връща обект от тип Time, което е разликата между двете времена.
* Член-функция, която която приема друг обект от тип Time и сравнява двата обекта (по-къснен/по-ранен)
* Член-функция за принтиране на часа.

## Задача втора
Нека имаме 256 града. Всеки град е номериран с число в интервала [0..255]. Път наричаме редица от вида [t1, t2, ..., tn] където t1 < t2 ... < tn. Да се създаде система за работа с такива пътища, която поддържа следните функционалности:

* Добавяне на град към пътя
* Премахване на град от пътя
* Проверка дали градът ще бъде посетен от пътя.
* Обединение на два пътя.
* Сечение на два пътя.
* Дали два пътя имат общи градове.
* Дали има някакви градове в пътя
* Колко са гррадовете в пътя
* Вземане на всички градове като масив от индексите им.